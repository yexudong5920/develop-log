# 一大组痛苦的maven循环依赖引发的对依赖反转原则的思考

## 起因

将项目的不同模块切分后，发现有些抽象逻辑上并不是紧耦合的模块，由于出现了互相调用，引发了maven的循环依赖。

例如：

A模块依赖B模块，B模块同时依赖A。（多个模块同理）

一般情况下，如果不是使用一些代码分析工具嗅探代码坏味道

    A.java中import B;
    B.java中import A;

其实十分常见，也不会出现编译错误。

但是在maven中，由于maven是根据依赖关键build package，所以一旦出现循环依赖，maven只能build失败，抛出循环依赖的异常。

也正是这个异常的频繁出现，给了我一个思考模块化、依赖倒置、解耦的契机。

## 循环依赖

循环依赖（[Circular dependency](https://en.wikipedia.org/wiki/Circular_dependency)）是指在软件工程中两个或多个模块之间直接或间接地相互依赖，这样的模块组也称之为互递归。

### 循环依赖的问题

* 从软件设计角度来说，最大的问题在于互相依赖的紧耦合模块降低甚至完全破坏了单个模块的可复用性。
* 当局部模块发生的变化传播到与之耦合的其他模块，其多米诺效应很有可能会造成整体的错误（包括程序错误、编译错误）。
* 循环依赖可能会阻止了使用引用计数（Reference counting）的垃圾回收器（garbage collectors）的自动释放无引用对象，造成内存泄漏。

## 非循环依赖原则

非循环依赖原则([Acyclic dependencies principle](https://en.wikipedia.org/wiki/Acyclic_dependencies_principle))作为一个软件开发原则其实一直存在（只是我没有知道这个概念），只是在maven这里由于事先机制引发了程序的构建错误。

### 依赖类型
软件依赖类型分为显式依赖和隐式依赖。

显式依赖的例子：
* include表达式，如C/C++中的#include，java中的import
* 构建系统中的依赖（如maven中的`dependency`）

[隐式依赖](http://programmer.97things.oreilly.com/wiki/index.php/Implicit_Dependencies_Are_also_Dependencies)的例子：
* 依靠暴露的接口中没有明确定义的行为（很常见，不能准确表达impl bean的interface方法名其实都在做隐式依赖）
* 网络协议

总体来说，无论何时，best practice都是优先使用显式依赖，因为更好分析与定位。

### 破除循环依赖的策略
* 依赖反转原则
* 将公用依赖放在一个新的package里

## 依赖反转原则
